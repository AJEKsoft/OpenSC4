[gd_scene load_steps=12 format=2]

[ext_resource path="res://City.gd" type="Script" id=1]
[ext_resource path="res://CameraAnchor3D.gd" type="Script" id=2]
[ext_resource path="res://Terrain.gd" type="Script" id=3]
[ext_resource path="res://WaterPlane.gd" type="Script" id=4]

[sub_resource type="Shader" id=4]
code = "shader_type spatial;

uniform sampler2DArray terrain : hint_albedo;
uniform int zoom;
uniform sampler2D layer;
uniform sampler2D watermap;
varying smooth vec3 coord_pass;
varying smooth float map_str;
const float PI = 3.14159265358979323846;
uniform float cliff_ind;
uniform float beach_ind;
uniform float tiling_factor;
uniform float water_height = 15.625; //250.0/16.0
uniform bool grid_bool = false;
uniform float beach_ht_range;

void vertex()
{
	coord_pass = VERTEX.xyz;
	
	map_str = (texelFetch(watermap, ivec2(coord_pass.zx), 0).r*beach_ht_range);
	//if (map_str < (beach_ht_range/2.0)){
	//	map_str = min(map_str, 1.0);
	//}
	//else{
	//	map_str = 0.0;
	//}
}

void fragment()
{
	float zoom_ind = min( float(zoom-1), 4.0);
	vec2 coord = coord_pass.xz;
	// might not be the fastest way of doing this
	ivec2 icoord1 = ivec2(coord);
	ivec2 icoord2 = icoord1 + ivec2(1, 0);
	ivec2 icoord3 = icoord1 + ivec2(0, 1);
	ivec2 icoord4 = icoord1 + ivec2(1, 1);
	float index1 = texelFetch(layer, icoord1, 0).r*255.0;
	float index2 = texelFetch(layer, icoord2, 0).r*255.0;
	float index3 = texelFetch(layer, icoord3, 0).r*255.0;
	float index4 = texelFetch(layer, icoord4, 0).r*255.0;
	vec2 rem1 = abs(vec2(icoord1) - coord);
	vec2 rem2 = abs(vec2(icoord2) - coord);
	vec2 rem3 = abs(vec2(icoord3) - coord);
	vec2 rem4 = abs(vec2(icoord4) - coord);
	vec3 grid = vec3(1.0, 1.0, 1.0);
	if (grid_bool){
		if (rem1.x < (0.05 * max((5.0-float(zoom_ind)), 0.0)) ){
			grid = vec3(0.6, 0.6, 0.6);
		}
		if (rem1.y < (0.05 * max((5.0-float(zoom_ind)), 0.0)) and grid_bool == true){
			grid = vec3(0.6, 0.6, 0.6);
		}
	}
	float str1 = ((cos((rem1.x)*PI)*0.5+0.5) * (cos((rem1.y)*PI)*0.5+0.5));
	float str2 = ((cos((rem2.x)*PI)*0.5+0.5) * (cos((rem2.y)*PI)*0.5+0.5));
	float str3 = ((cos((rem3.x)*PI)*0.5+0.5) * (cos((rem3.y)*PI)*0.5+0.5));
	float str4 = ((cos((rem4.x)*PI)*0.5+0.5) * (cos((rem4.y)*PI)*0.5+0.5));
	float sum_str = str1 + str2 + str3 + str4;
	vec3 col1 = texture(terrain, vec3(UV.x*tiling_factor, UV.y*tiling_factor, float(zoom_ind)+index1)).rgb * (str1/sum_str);
	vec3 col2 = texture(terrain, vec3(UV.x*tiling_factor, UV.y*tiling_factor, float(zoom_ind)+index2)).rgb * (str2/sum_str);
	vec3 col3 = texture(terrain, vec3(UV.x*tiling_factor, UV.y*tiling_factor, float(zoom_ind)+index3)).rgb * (str3/sum_str);
	vec3 col4 = texture(terrain, vec3(UV.x*tiling_factor, UV.y*tiling_factor, float(zoom_ind)+index4)).rgb * (str4/sum_str);
	//cliffs
	vec3 overlay = vec3(0.0, 0.0, 0.0);
	vec3 underlay = vec3(0.0, 0.0, 0.0);
	float over_str = 0.0;
	float under_str = 0.0;
	float beachy = ((coord_pass.y) - water_height);
	if (abs(NORMAL.y) < 0.5){
		over_str = max(min(((0.5-abs(NORMAL.y))*2.2), 1.0), 0.0);
		if (abs(NORMAL.x) < abs(NORMAL.z)){
			overlay = texture(terrain, vec3(UV.y*tiling_factor, UV.x*tiling_factor, float(zoom_ind)+cliff_ind)).rgb;
		}
		else{
			overlay = texture(terrain, vec3(UV.x*tiling_factor, UV.y*tiling_factor, float(zoom_ind)+cliff_ind)).rgb;
		}
	}
	if(beachy < 4.0){
		under_str = max(min(((4.0*map_str)-(beachy)), 1.0), 0.0);
		underlay = texture(terrain, vec3(UV.y*tiling_factor, UV.x*tiling_factor, float(zoom_ind)+beach_ind)).rgb;
	}
	

		ALBEDO = (
					(
						(
							(
							(col1 + col2 + col3 + col4) * (1.0-over_str)
							) 
						+ (overlay * over_str)
						)
					 * (1.0 - under_str)
					) 
					+ (underlay * under_str)
				) * grid;
		//ALBEDO = texture(layer, UV).rgb;
		
	}"

[sub_resource type="ShaderMaterial" id=5]
shader = SubResource( 4 )
shader_param/zoom = null
shader_param/cliff_ind = null
shader_param/beach_ind = null
shader_param/tiling_factor = null
shader_param/water_height = 15.625
shader_param/grid_bool = false
shader_param/beach_ht_range = null

[sub_resource type="Shader" id=9]
code = "shader_type spatial;

uniform sampler2D watermap;
uniform sampler2DArray watertexture : hint_albedo;
uniform int zoom;
uniform float tiling_factor;
uniform float max_depth;
uniform float depth_range;
varying float depth_alpha;
varying vec3 depth_color;

void vertex(){
	float depth = texelFetch(watermap, ivec2(VERTEX.xz), 0).r;
	depth_color = vec3((.75), (.75), (.75));
	depth_alpha = min(depth*1.0, 1.0);
	
}

void fragment(){
	float zoom_ind = min( float(zoom-1), 4.0);
	ALBEDO = texture(watertexture, vec3(UV*tiling_factor, float(zoom_ind))).rgb*depth_color;
	ALPHA = depth_alpha;
}"

[sub_resource type="ShaderMaterial" id=10]
shader = SubResource( 9 )
shader_param/zoom = null
shader_param/tiling_factor = null
shader_param/max_depth = null
shader_param/depth_range = null

[sub_resource type="Shader" id=7]
code = "shader_type spatial;

uniform sampler2DArray terrain : hint_albedo;
uniform int zoom;
varying smooth float height_var;
varying flat float height_flat;
const float PI = 3.14159265358979323846;
uniform float tiling_factor;
uniform float top_ind;
uniform float mid_ind;
uniform float bot_ind;

void vertex()
{
	height_var = VERTEX.y;
	height_flat = VERTEX.y;
	
}

void fragment()
{
	float edge_tex = 0.0;
	float zoom_ind = min(float(zoom), 4.0);
	if (UV.y > 0.3152){
		edge_tex = bot_ind;
		}
	else{  
		if(UV.y > 0.1576){
			edge_tex = mid_ind;
		}
		else{
			edge_tex = top_ind;
		}
	}
	float uvx = UV.x*tiling_factor;
	float uvy = UV.y*tiling_factor;
	if (zoom < 4){
		float div = 1.0 / pow(2.0, float(4-zoom)); // farther zooms (lower zoom value) have smaller textures
		uvx = mod(uvx, div);
		uvy = mod(uvy, div);
	}
	ALBEDO = texture(terrain, vec3(uvx, uvy, float(zoom_ind)+edge_tex)).rgb;
}"

[sub_resource type="ShaderMaterial" id=8]
shader = SubResource( 7 )
shader_param/zoom = null
shader_param/tiling_factor = null
shader_param/top_ind = null
shader_param/mid_ind = null
shader_param/bot_ind = null

[sub_resource type="Environment" id=1]
ambient_light_color = Color( 1, 1, 1, 1 )
ambient_light_energy = 0.2

[node name="City" type="Spatial"]
script = ExtResource( 1 )

[node name="Spatial" type="Spatial" parent="."]
transform = Transform( -0.924, 0, 0.383, 0, -1, 1, 0.191, 0.866, 0.462, 0, 0, 0 )

[node name="Terrain" type="MeshInstance" parent="Spatial"]
transform = Transform( 4.37114e-08, 0, -1, 0, 1, 0, -1, 0, -4.37114e-08, 0, 0, 0 )
material_override = SubResource( 5 )
cast_shadow = 0
skeleton = NodePath("../..")
script = ExtResource( 3 )

[node name="WaterPlane" type="MeshInstance" parent="Spatial"]
transform = Transform( -1, 0, 8.74228e-08, 0, 1, 0, -8.74228e-08, 0, -1, 0, 0, 0 )
material_override = SubResource( 10 )
skeleton = NodePath("../..")
script = ExtResource( 4 )

[node name="Border" type="MeshInstance" parent="Spatial"]
transform = Transform( -4.37114e-08, -3.82137e-15, -1, -8.74228e-08, 1, 0, -1, -8.74228e-08, 4.37114e-08, 0, 0, 0 )
material_override = SubResource( 8 )

[node name="Sun" type="DirectionalLight" parent="Spatial"]
transform = Transform( 1.05984, -0.1417, 0.227311, 0, 0.762665, 0.304699, 0, -5.96046e-08, 0.951493, 35.2, 57.5, 47.4 )
light_energy = 0.95
light_indirect_energy = 0.3
directional_shadow_mode = 0
directional_shadow_normal_bias = 1.5
directional_shadow_max_distance = 1500.0

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource( 1 )
__meta__ = {
"_editor_description_": "Default environment"
}

[node name="KinematicBody" type="KinematicBody" parent="."]
script = ExtResource( 2 )

[node name="Camera" type="Camera" parent="KinematicBody"]
transform = Transform( 1, 0, 0, 0, -4.37114e-08, -1, 0, 1, -4.37114e-08, 0, -500, 0 )
projection = 1
current = true
size = 292.0
far = 5000.0
